using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Jellyfin.Database.Implementations.Entities;
using Jellyfin.Plugin.SmartLists.Core;
using Jellyfin.Plugin.SmartLists.Services.Shared;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.TV;
using MediaBrowser.Controller.Library;
using Microsoft.Extensions.Logging;

namespace Jellyfin.Plugin.SmartLists.Core.Orders
{
    public class NameIgnoreArticlesOrder : PropertyOrder<string>
    {
        private static readonly Regex AutoGeneratedSortNamePattern = 
            new(@"^\d{3,} - \d{4,} - ", RegexOptions.Compiled);
        
        public override string Name => "Name (Ignore Articles) Ascending";
        protected override bool IsDescending => false;
        protected override IComparer<string> Comparer => OrderUtilities.SharedNaturalComparer;

        protected override string GetSortValue(BaseItem item, User? user = null, IUserDataManager? userDataManager = null, ILogger? logger = null, RefreshQueueService.RefreshCache? refreshCache = null)
        {
            return ComputeNameIgnoreArticlesSortValue(item);
        }

        /// <summary>
        /// Shared logic for computing name with articles stripped
        /// </summary>
        public static string ComputeNameIgnoreArticlesSortValue(BaseItem item)
        {
            ArgumentNullException.ThrowIfNull(item);
            
            // For Episodes, SortName is auto-generated as "001 - 0001 - Title".
            // We want to sort by Title (ignoring articles) UNLESS manual SortName is set.
            if (item is Episode && !string.IsNullOrEmpty(item.SortName) &&
                AutoGeneratedSortNamePattern.IsMatch(item.SortName))
            {
                return OrderUtilities.StripLeadingArticles(item.Name ?? "");
            }
            
            // Use SortName as-is (no article stripping) when present, else strip articles from Name
            return !string.IsNullOrEmpty(item.SortName)
                ? item.SortName
                : OrderUtilities.StripLeadingArticles(item.Name ?? "");
        }
    }

    public class NameIgnoreArticlesOrderDesc : PropertyOrder<string>
    {
        public override string Name => "Name (Ignore Articles) Descending";
        protected override bool IsDescending => true;
        protected override IComparer<string> Comparer => OrderUtilities.SharedNaturalComparer;

        protected override string GetSortValue(BaseItem item, User? user = null, IUserDataManager? userDataManager = null, ILogger? logger = null, RefreshQueueService.RefreshCache? refreshCache = null)
        {
            return NameIgnoreArticlesOrder.ComputeNameIgnoreArticlesSortValue(item);
        }
    }
}

